import argparse
import csv
from dataclasses import dataclass
from pathlib import Path
import sys
from typing import Iterable, List, Optional, Union

from wilddiac_utils import normalize_consonants, normalize_diac


"""Full list of columns that would be output to a TSV file.
"""
OUTPUT_COLUMNS_ALL = (
    'genre',
    'num_words',
    'oov',
    'ct_noctx_accuracy',
    'ct_soloctx_accuracy',
    'ct_fullctx_accuracy',
    'ctpp_soloctx_accuracy',
    'ctpp_fullctx_accuracy',
    'oracle_noctx_accuracy',
    'oracle_soloctx_accuracy',
    'oracle_fullctx_accuracy',
)

@dataclass
class ProcessedArgs:
    genre_paths: List[tuple[str, Path]]
    output_path: Path
    columns: List[str]
    norm_consonants: bool
    norm_diac: bool
    use_gold_alt: bool


@dataclass
class EvalStatistics:
    """Container class for all statistics to be tracked.
    """

    num_words: int = 0
    num_oov: int = 0
    ct_noctx: int = 0
    ct_soloctx: int = 0
    ct_fullctx: int = 0
    ctpp_soloctx: int = 0
    ctpp_fullctx: int = 0
    oracle_noctx: int = 0
    oracle_soloctx: int = 0
    oracle_fullctx: int = 0

    def __add__(self, other: 'EvalStatistics') -> 'EvalStatistics':
        return EvalStatistics(
            num_words=self.num_words + other.num_words,
            num_oov=self.num_oov + other.num_oov,
            ct_noctx=self.ct_noctx + other.ct_soloctx,
            ct_soloctx=self.ct_soloctx + other.ct_soloctx,
            ct_fullctx=self.ct_fullctx + other.ct_fullctx,
            ctpp_soloctx=self.ctpp_soloctx + other.ctpp_soloctx,
            ctpp_fullctx=self.ctpp_fullctx + other.ctpp_fullctx,
            oracle_noctx=self.oracle_noctx + other.oracle_noctx,
            oracle_soloctx=self.oracle_noctx + other.oracle_soloctx,
            oracle_fullctx=self.oracle_fullctx + other.oracle_fullctx,
        )

    def __iadd__(self, other: 'EvalStatistics'):
        self.num_words += other.num_words
        self.num_oov += other.num_oov
        self.ct_noctx += other.ct_noctx
        self.ct_soloctx += other.ct_soloctx
        self.ct_fullctx += other.ct_fullctx
        self.ctpp_soloctx += other.ctpp_soloctx
        self.ctpp_fullctx += other.ctpp_fullctx
        self.oracle_noctx += other.oracle_noctx
        self.oracle_soloctx += other.oracle_soloctx
        self.oracle_fullctx += other.oracle_fullctx

        return self


def create_argparser() -> argparse.ArgumentParser:
    """Create and populate and ArgumentParser instance.
    """

    parser = argparse.ArgumentParser(
        prog='evaluate.py',
        description='Evaluate diacritization predictions from an input file.'
    )

    parser.add_argument(
        '-o', '--output',
        help='path where output file will be written',
        required=True
    )

    parser.add_argument(
        '--all',
        help='output all evaluations and statistics',
        action='store_true',
        default=False
    )

    parser.add_argument(
        '--oov',
        help='output out-of-vocabulary statistics',
        action='store_true',
        default=False
    )

    parser.add_argument(
        '--ct-noctx',
        help='output evalaution of original CAMeL Tools diacritization with no contextual fixes',
        action='store_true',
        default=False
    )

    parser.add_argument(
        '--ct-soloctx',
        help='output evalaution of original CAMeL Tools diacritization using solo context fixes',
        action='store_true',
        default=False
    )

    parser.add_argument(
        '--ct-fullctx',
        help='output evalaution of original CAMeL Tools diacritization using full context fixes',
        action='store_true',
        default=False
    )

    parser.add_argument(
        '--ctpp-soloctx',
        help='output evalaution of original CT++ diacritization using solo context fixes',
        action='store_true',
        default=False
    )

    parser.add_argument(
        '--ctpp-fullctx',
        help='output evalaution of original CT++ diacritization using full context fixes',
        action='store_true',
        default=False
    )

    parser.add_argument(
        '--oracle-noctx',
        help='output evalaution of oracle diacritization with no contextual fixes',
        action='store_true',
        default=False
    )

    parser.add_argument(
        '--oracle-soloctx',
        help='output evalaution of oracle diacritization using solo context fixes',
        action='store_true',
        default=False
    )

    parser.add_argument(
        '--oracle-fullctx',
        help='output evalaution of oracle diacritization using full context fixes',
        action='store_true',
        default=False
    )

    parser.add_argument(
        '--norm-diac',
        help='normalize diacritics when evaluating',
        action='store_true',
        default=False
    )

    parser.add_argument(
        '--norm-consonants',
        help='normalize consonants when evaluating',
        action='store_true',
        default=False
    )

    parser.add_argument(
        '--use-gold-alt',
        help='use alternate gold diacritization for evaluation',
        action='store_true',
        default=False
    )

    parser.add_argument(
        'INPUT',
        help=(
            'The input predictions file and its respective genre to '
            'evaluate. Each INPUT should be of the form GENRE:PATH where '
            'PATH is a path to an input prediction file and GENRE is the '
            'genre that file belongs to. '
            'Files with the same genre will have their statistics accumulated.'
        ),
        nargs='+',
    )

    return parser


def determine_output_columns(args: argparse.Namespace) -> List[str]:
    """Determines the list of TSV columns to be written in the output path
    based on the command-line arguments passed.
    """

    if args.all:
        return List(OUTPUT_COLUMNS_ALL)

    columns = ['genre', 'num_words']

    if args.oov:
        columns.append('oov')
    if args.ct_noctx:
        columns.append('ct_noctx_accuracy')
    if args.ct_soloctx:
        columns.append('ct_soloctx_accuracy')
    if args.ct_fullctx:
        columns.append('ct_fullctx_accuracy')
    if args.ctpp_soloctx:
        columns.append('ctpp_soloctx_accuracy')
    if args.ctpp_fullctx:
        columns.append('ctpp_fullctx_accuracy')
    if args.oracle_noctx:
        columns.append('oracle_noctx_accuracy')
    if args.oracle_soloctx:
        columns.append('oracle_soloctx_accuracy')
    if args.oracle_fullctx:
        columns.append('oracle_fullctx_accuracy')

    return columns


def parse_genre_path_args(args: Iterable[str]) -> List[tuple[str, Path]]:
    """Parses genre-path command-line arguments of the form 'genre:path' to
    return tuples of (genre, path). If the argument is of the form just 'path',
    then genre is the empty string ''.
    """

    result = []

    for arg in args:
        tokens = arg.split(':', 1)

        if len(tokens) == 2:
            result.append((tokens[0], Path(tokens[1])))
        else:
            result.append(('', Path(tokens[0])))

    return result


def process_args(args: argparse.Namespace) -> ProcessedArgs:
    """Convert parsed args into a ProcessedArgs instance which provides typing
    information and a more consistent naming convention.
    """

    columns = determine_output_columns(args)

    return ProcessedArgs(
        genre_paths=parse_genre_path_args(args.INPUT),
        output_path=Path(args.output),
        columns=columns,
        norm_consonants=args.norm_consonants,
        norm_diac=args.norm_diac,
        use_gold_alt=args.use_gold_alt,
    )


def gen_prediction_rows(path: Path) -> Iterable[dict[str, str]]:
    """Iterates over rows in a TSV file, generating a dictionary for each.
    """

    with path.open('r', encoding='utf-8') as fp:
        reader = csv.DictReader(fp,
                                dialect='excel-tab',
                                quotechar=None,
                                quoting=csv.QUOTE_NONE)
        for row in reader:
            yield row


def normalize_word(word: Optional[str],
                   norm_consonants: bool,
                   norm_diac: bool) -> Optional[str]:
    """Normalize a word before comparison.
    """

    if word is None:
        return None

    word = word.strip()

    if norm_consonants:
        word = normalize_consonants(word)

    if norm_diac:
        word = normalize_diac(word)

    return word


def calculate_stats(predictions: Iterable[dict[str, str]],
                    args: ProcessedArgs) -> EvalStatistics:
    """Calculate statistics from given list of predictions.
    """

    norm_cons = args.norm_consonants
    norm_diac = args.norm_diac
    use_gold_alt = args.use_gold_alt
    stats = EvalStatistics()

    for pred in predictions:
        stats.num_words += 1

        if pred['is_oov'].lower() == 'true':
            stats.num_oov += 1

        gold_diac = normalize_word(pred['gold_diac'], norm_cons, norm_diac)

        # Avoid counting empty lines.
        if gold_diac == '':
            continue

        gold_diac_alt = normalize_word(pred.get('gold_diac_alt', gold_diac),
                                       norm_cons,
                                       norm_diac)
        if gold_diac_alt == '':
            gold_diac_alt = gold_diac

        ct_noctx = normalize_word(pred.get('ct_diac_noctx', None),
                                  norm_cons,
                                  norm_diac)
        ct_soloctx = normalize_word(pred.get('ct_diac_soloctx', None),
                                    norm_cons,
                                    norm_diac)
        ct_fullctx = normalize_word(pred.get('ct_diac_fullctx', None),
                                    norm_cons,
                                    norm_diac)
        ctpp_soloctx = normalize_word(pred.get('ctpp_diac_soloctx', None),
                                      norm_cons,
                                      norm_diac)
        ctpp_fullctx = normalize_word(pred.get('ctpp_diac_fullctx', None),
                                      norm_cons,
                                      norm_diac)
        oracle_noctx = normalize_word(pred.get('oracle_diac_noctx', None),
                                      norm_cons,
                                      norm_diac)
        oracle_soloctx = normalize_word(pred.get('oracle_diac_soloctx', None),
                                        norm_cons,
                                        norm_diac)
        oracle_fullctx = normalize_word(pred.get('oracle_diac_fullctx', None),
                                        norm_cons,
                                        norm_diac)

        # Increment all relevant statistics based on equality with full_diac or
        # full_diac_alt.
        if ct_noctx is None:
            pass
        elif ct_noctx == gold_diac:
            stats.ct_noctx += 1
        elif use_gold_alt and ct_noctx == gold_diac_alt:
            stats.ct_noctx += 1

        if ct_soloctx is None:
            pass
        elif ct_soloctx == gold_diac:
            stats.ct_soloctx += 1
        elif use_gold_alt and ct_soloctx == gold_diac_alt:
            stats.ct_soloctx += 1

        if ct_fullctx is None:
            pass
        elif ct_fullctx == gold_diac:
            stats.ct_fullctx += 1
        elif use_gold_alt and ct_fullctx == gold_diac_alt:
            stats.ct_fullctx += 1

        if ctpp_soloctx is None:
            pass
        elif ctpp_soloctx == gold_diac:
            stats.ctpp_soloctx += 1
        elif use_gold_alt and ctpp_soloctx == gold_diac_alt:
            stats.ctpp_soloctx += 1

        if ctpp_fullctx is None:
            pass
        elif ctpp_fullctx == gold_diac:
            stats.ctpp_fullctx += 1
        elif use_gold_alt and ctpp_fullctx == gold_diac_alt:
            stats.ctpp_fullctx += 1

        if oracle_noctx is None:
            pass
        elif oracle_noctx == gold_diac:
            stats.oracle_noctx += 1
        elif use_gold_alt and oracle_noctx == gold_diac_alt:
            stats.oracle_noctx += 1

        if oracle_soloctx is None:
            pass
        elif oracle_soloctx == gold_diac:
            stats.oracle_soloctx += 1
        elif use_gold_alt and oracle_soloctx == gold_diac_alt:
            stats.oracle_soloctx += 1

        if oracle_fullctx is None:
            pass
        elif oracle_fullctx == gold_diac:
            stats.oracle_fullctx += 1
        elif use_gold_alt and oracle_fullctx == gold_diac_alt:
            stats.oracle_fullctx += 1

    return stats


def format_as_percentage(ratio: float) -> str:
    """Formats a ratio (number between 0 and 1) to a percentage rounded to
    one decimal place.
    """

    percentage = 100.0 * ratio

    return '{0:.1f}%'.format(percentage)


def stats_to_csv_dict(genre: str, stats: EvalStatistics) -> dict[str, str]:
    """Converts an EvalStatistics object to a dictionary that would be passed
    to a csv.DictWriter.
    """

    num_words = stats.num_words

    # Avoid division by zero when number of words is 0, returning 0% instead
    if num_words == 0:
        stats = EvalStatistics()
        stats.num_words += 1

    oov = stats.num_oov / num_words
    ct_noctx_acc = stats.ct_noctx / num_words
    ct_soloctx_acc = stats.ct_soloctx / num_words
    ct_fullctx_acc = stats.ct_fullctx / num_words
    ctpp_soloctx_acc = stats.ctpp_soloctx / num_words
    ctpp_fullctx_acc = stats.ctpp_fullctx / num_words
    oracle_noctx_acc = stats.oracle_noctx / num_words
    oracle_soloctx_acc = stats.oracle_soloctx / num_words
    oracle_fullctx_acc = stats.oracle_fullctx / num_words

    result = {
        'genre': genre,
        'num_words': stats.num_words,
        'oov': format_as_percentage(oov),
        'ct_noctx_accuracy': format_as_percentage(ct_noctx_acc),
        'ct_soloctx_accuracy': format_as_percentage(ct_soloctx_acc),
        'ct_fullctx_accuracy': format_as_percentage(ct_fullctx_acc),
        'ctpp_soloctx_accuracy': format_as_percentage(ctpp_soloctx_acc),
        'ctpp_fullctx_accuracy': format_as_percentage(ctpp_fullctx_acc),
        'oracle_noctx_accuracy': format_as_percentage(oracle_noctx_acc),
        'oracle_soloctx_accuracy': format_as_percentage(oracle_soloctx_acc),
        'oracle_fullctx_accuracy': format_as_percentage(oracle_fullctx_acc),
    }

    return result


def write_genre_stats(path: Path,
                      columns: List[str],
                      genre_stats: dict[str, EvalStatistics]):
    """Write computed genre statstics to a TSV file at a given path, writing
    only the specified columns.
    """

    genres = sorted(genre_stats.keys())
    all_stats = EvalStatistics()

    with path.open('w', encoding='utf-8', newline='\n') as fp:
        writer = csv.DictWriter(fp,
                                dialect='excel-tab',
                                fieldnames=columns,
                                quotechar=None,
                                quoting=csv.QUOTE_NONE,
                                extrasaction='ignore',
                                lineterminator='\n')
        writer.writeheader()

        # Write rows for each individual genre statistics
        for genre in genres:
            stats = genre_stats[genre]
            all_stats += stats
            stats_dict = stats_to_csv_dict(genre, stats)
            writer.writerow(stats_dict)

        # Write row for combined statistics
        all_stats_dict = stats_to_csv_dict('[ALL]', all_stats)
        writer.writerow(all_stats_dict)


def main():
    # Parse command-line arguments
    argparser = create_argparser()
    args = argparser.parse_args()
    args = process_args(args)

    genre_stats = {}
    for genre, path in args.genre_paths:
        # Calculate staistics for each file
        rows = gen_prediction_rows(path)
        stats = calculate_stats(rows, args)

        # If two or mor files have the same genre, sum up their statistics
        if genre in genre_stats:
            genre_stats[genre] += stats
        else:
            genre_stats[genre] = stats

    # Write statistics to TSV file
    write_genre_stats(args.output_path, args.columns,  genre_stats)


if __name__ == '__main__':
    main()
